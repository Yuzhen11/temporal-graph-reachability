#include <iostream>
#include <algorithm>
#include <vector>
#include <fstream>
#include <queue>
#include <string>
#include <cstring>
#include <assert.h>
#include <set>
#include "Timer.h"
using namespace std;
vector<vector<int> > v;
vector<vector<int> > vr;
int n, m;
vector<int> ind;
vector<int> outd;
vector<int> Lup;
vector<int> Ldown;


vector<vector<pair<int, int> > > Lin;
vector<vector<pair<int, int> > > Lout;

struct Node
{
	int value;
	int pos;
	int arrayNum;
	Node(){}
	Node(int value, int pos, int arrayNum):value(value),pos(pos), arrayNum(arrayNum){}
	Node(pair<int,int> p, int newPos)
	{
		value = p.first;
		pos = p.second;
		arrayNum = newPos;
	}
	bool operator<(const Node &n2) const
	{
		if (value == n2.value) return pos > n2.pos;
		return value > n2.value;
	}
};

int k = 5;
int h;

Timer timer;

vector<int> rank;
vector<int> reverseRank;

void readGraph(string s)
{
	timer.start();
	fstream in;
	in.open(s.c_str(), ios::in);
	in >> n >> m;
	v.resize(n);
	vr.resize(n);
	ind.resize(n);
	outd.resize(n);
	
	int u;int size;int to;
	while(in >> u)
	{
		in >> size;
		for (int i = 0; i < size; ++ i)
		{
			in >> to;
			v[u].push_back(to);
			vr[to].push_back(u);
			outd[u]++;
			ind[to]++;
		} 
	}
	in.close();
	timer.stop();
	cout << "read graph time: " << timer.GetRuntime() << endl;
	
	cout << "load done." << endl;
	
	
}

int chainNum;
vector<int> vis;
vector<int> toChain;
vector<int> toPos;
vector<vector<int> > toV;
void dfs(int from)
{
	vis[from] = 1;
	toChain[from] = chainNum;
	toPos[from] = toV[chainNum].size();
	
	toV[chainNum].push_back(from);
	for (int i = 0;  i < v[from].size(); ++ i)
	{
		if (!vis[v[from][i]])
		{
			dfs(v[from][i]);
			return;
		}
	}
	return;
}

void handle()
{
	timer.start();
	//topological sort
	
	//find rank 
	//random
	/*
	rank.resize(n);
	for (int i = 0; i < n; ++ i)
	{
		rank[i] = i;
	}
	for (int i = n-1; i > 0; -- i)
	{
		int j = rand()%(i+1);
		swap(rank[i], rank[j]);
	}
	*/
	
	Ldown.resize(n);
	Lup.resize(n);
	Lin.resize(n);
	Lout.resize(n);
	queue<int> q;
	queue<int> q1;
	int count1 = 0;
	int maxDown = 0;
	int maxUp = 0;
	for (int i = 0; i < n; ++ i)
	{
		if (ind[i] == 0) 
		{
			Ldown[i] = 0;	
			q.push(i);
		}
		if (outd[i] == 0)
		{
			Lup[i] = 0;
			q1.push(i);
		}
		//Lin[i].push_back(rank[i]);
		//Lout[i].push_back(rank[i]);
	}
	
	
	//find chain
	
	vector<int> ind2;
	vector<int> ts;
	ind2.resize(n);
	
	vis.resize(n);
	queue<int> q2;
	for (int i = 0; i < n; ++ i)  ind2[i] = ind[i];
	for (int i = 0; i < n; ++ i)
	{
		vis[i] = 0;
		if (ind2[i] == 0) q2.push(i);
	}
	while(!q2.empty())
	{
		int tmp = q2.front();
		q2.pop();
		ts.push_back(tmp);
		for (int i = 0; i < v[tmp].size(); ++ i)
		{
			ind2[v[tmp][i]]--;
			if (ind2[v[tmp][i]] == 0)
			{
				q2.push(v[tmp][i]);
			}
		}
	}
	assert(ts.size() == n);

	chainNum = 0;
	toV.resize(n);
	toChain.resize(n);
	toPos.resize(n);
	for (int i = 0; i < n; ++ i)
	{
		if (!vis[ts[i]])
		{
			dfs(ts[i]);
			chainNum ++;
		}
	}
	cout <<"chain Num : "<< chainNum << endl;
	
	int countt = 0;
	for (int i = 0; i < chainNum; ++ i)
	{
		countt += toV[i].size();
	}
	assert(countt == n);
	
	//-------------------------------------------------------------
	//assign rank
	rank.resize(chainNum);
	for (int i = 0; i < chainNum; ++ i)
	{
		rank[i] = i;
	}
	for (int i = chainNum-1; i > 0; -- i)
	{
		int j = rand()%(i+1);
		swap(rank[i], rank[j]);
	}
	//------------------
	
	set<int> s;
	while(!q.empty())
	{
		int tmp = q.front();
		q.pop();
		count1++;
		for (int i = 0; i < v[tmp].size(); ++ i)
		{
			ind[v[tmp][i]]--;
			if (ind[v[tmp][i]] == 0) 
			{
				Ldown[v[tmp][i]] = Ldown[tmp]+1;
				q.push(v[tmp][i]);
				maxDown = Ldown[v[tmp][i]];
			}
		}
	
		//IP construct
		
		/*
		s.clear();	
		for (int i = 0; i < vr[tmp].size(); ++ i)
		{
			int nin = vr[tmp][i];
			for (int j = 0; j < Lin[nin].size(); ++ j) s.insert(Lin[nin][j]);
		}
		s.insert(rank[tmp]);
		int countk = 0;
		//cout << s.size() << endl;
		for (set<int>::iterator it = s.begin(); it != s.end(); it ++)
		{
			Lin[tmp].push_back(*it);
			countk++;
			if (countk == k) break;
		}
		*/
		
		// find top k  using multi merge
		priority_queue<Node> pq;
		//queue<Node>pq;
		pq.push(Node(rank[toChain[tmp]], toPos[tmp], -1));
		int pArray[vr[tmp].size()];
		memset(pArray,0,sizeof(pArray));
		for (int i = 0; i < vr[tmp].size(); ++ i)
		{
			int nin = vr[tmp][i];
			pq.push(Node(Lin[nin][0].first, Lin[nin][0].second, i));
		}
		//cout <<"!"<< endl;
		//cout <<pq.size() << endl;
		for (int i = 0; i < k; ++ i)
		{
			if (pq.empty()) break;
			while(!pq.empty())
			{
				//cout << pq.size() << endl;
				Node topNode = pq.top();pq.pop();
				//cout << topNode.value << " " << topNode.arrayNum << endl;
				if (topNode.arrayNum == -1)
				{	
					//cout << "HI" << endl;
					Lin[tmp].push_back(make_pair(topNode.value, topNode.pos));
					break;
				}
				pArray[topNode.arrayNum] ++;
				if (pArray[topNode.arrayNum] < Lin[vr[tmp][topNode.arrayNum]].size()) 
				{pq.push(Node(Lin[vr[tmp][topNode.arrayNum]][pArray[topNode.arrayNum]], topNode.arrayNum) ); }
				
				if (Lin[tmp].size() == 0) 
				{Lin[tmp].push_back(make_pair(topNode.value, topNode.pos));
				break;}
				else if (Lin[tmp].back().first != topNode.value) 
				{
					Lin[tmp].push_back(make_pair(topNode.value, topNode.pos));
					break;
				}
			}
		}
		
	}
	while(!q1.empty())
	{
		int tmp = q1.front();
		q1.pop();
		for (int i = 0; i < vr[tmp].size(); ++ i)
		{
			outd[vr[tmp][i]]--;
			if (outd[vr[tmp][i]] == 0) 
			{
				Lup[vr[tmp][i]] = Lup[tmp]+1;
				q1.push(vr[tmp][i]);
				maxUp = Lup[vr[tmp][i]];
			}
		}
		
		//IP construct
		/*
		vector<int> test;
		s.clear();	
		for (int i = 0; i < v[tmp].size(); ++ i)
		{
			int nout = v[tmp][i];
			for (int j = 0; j < Lout[nout].size(); ++ j) s.insert(Lout[nout][j]);
		}
		s.insert(rank[tmp]);
		int countk = 0;
//		cout << s.size() << endl;
		for (set<int>::iterator it = s.begin(); it != s.end(); it ++)
		{
			test.push_back(*it);
			countk++;
			if (countk == k) break;
		}
		*/
		
		// find top k  using multi merge
		priority_queue<Node> pq;
		//queue<Node>pq;
		pq.push(Node(rank[toChain[tmp]], toPos[tmp], -1));
		int pArray[v[tmp].size()];
		memset(pArray,0,sizeof(pArray));
		for (int i = 0; i < v[tmp].size(); ++ i)
		{
			int nin = v[tmp][i];
			pq.push(Node(Lout[nin][0], i));
		}
		//cout <<"!"<< endl;
		//cout <<pq.size() << endl;
		for (int i = 0; i < k; ++ i)
		{
			if (pq.empty()) break;
			while(!pq.empty())
			{
				//cout << pq.size() << endl;
				Node topNode = pq.top();pq.pop();
				//cout << topNode.value << " " << topNode.arrayNum << endl;
				if (topNode.arrayNum == -1)
				{	
					//cout << "HI" << endl;
					Lout[tmp].push_back(make_pair(topNode.value, topNode.pos));
					break;
				}
				pArray[topNode.arrayNum] ++;
				if (pArray[topNode.arrayNum] < Lout[v[tmp][topNode.arrayNum]].size()) 
				{pq.push(Node(Lout[v[tmp][topNode.arrayNum]][pArray[topNode.arrayNum]], topNode.arrayNum) ); }
				
				if (Lout[tmp].size() == 0)
				{ Lout[tmp].push_back(make_pair(topNode.value, topNode.pos));
					break;
				}
				else if (Lout[tmp].back().first != topNode.value) 
				{
					Lout[tmp].push_back(make_pair(topNode.value, topNode.pos));
					break;
				}
			}
		}
		/*
		//compare test and Lout[tmp]
		int a;
		if (test.size() != Lout[tmp].size())
		{
			cout << tmp << endl;
			cout << test.size() << " " << Lout[tmp].size() << endl;
			cout <<"!!" << endl;
			cin >>a;
		}
		for (int i = 0; i < test.size(); ++ i)
		{
			if (test[i] != Lout[tmp][i])
			{
				cout << "!" << endl;
				cin >> a;
			}
		}
		*/
		
		
	}
	cout << "label done. " << endl;
	assert(count1 == n);
	
	cout << "maxUp : " << maxUp << endl;
	cout << "maxDown : " << maxDown << endl;



	vector<int>().swap(ind);
	vector<int>().swap(outd);

	//find Sin Sout
	

	

	timer.stop();
	cout << "topological sort and assign rank " << timer.GetRuntime() << endl;
	cout << "sort done" << endl;
}
//--------------------------label------------------------

/*
bool intersect(int u1, int u2)
{
	int p1 = 0;
	int p2 = 0;
	while(p1 < Lout[u1].size() && p2 < Lin[u2].size())
	{
		if (Lout[u1][p1] == Lin[u2][p2]) return 1;
		else if (Lout[u1][p1] < Lin[u2][p2]) p1 ++;
		else p2++;
	}
	return 0;
}
*/
//----------------------query----------------------------
int mark = 0;
int *flag;

bool IPtest(int from, int to)
{

	int p1 = 0; int p2 = 0;
	
	if (Lout[from][Lout[from].size()-1] > Lout[to][0]) {
		while(p1 < Lout[from].size() && p2 < Lout[to].size())
		{
			if (Lout[from][p1].first == Lout[to][p2].first) {p1++;p2++;}
			else if (Lout[from][p1].first < Lout[to][p2].first) {p1++;}
			else return 1;
		}
	}
	
	p1 = 0; p2 = 0;
	if (Lin[from][0] < Lin[to][Lin[to].size()-1])
	{
		while(p1 < Lin[from].size() && p2 < Lout[to].size())
		{
			if (Lin[from][p1].first == Lin[from][p2].first) {p1++;p2++;}
			else if (Lin[from][p1].first > Lin[to][p2].first) p2++;
			else return 1;
		}
	}
	
	
	return 0;
}
/*
bool insidetest(int from, int to)
{
	//linear search
	for (int i = 0; i < Lout[from].size(); ++ i)
	{
		if (Lout[from][i] == rank[to]) return 1;
	}
	return 0;
	
	
	int l = 0; int r = Lout[from].size()-1;
	int m;
	while(l <= r)
	{
		m = (l+r)/2;
		if (Lout[from][m] == rank[to]) return 1;
		else if (Lout[from][m] < rank[to]) l = m+1;
		else r = m-1;
	}
	return 0;
}
*/
bool query(int from, int to)
{
	if (from == to) return 1;
	
	//if (Ldown[from] >= Ldown[to] || Lup[from] <= Lup[to]) return 0;
	
	if (toChain[from] == toChain[to] ) return 1;
	if (IPtest(from, to)) return 0;
//	if (insidetest(from, to)) return 1;
	
	flag[from] = mark;
	//intersect or no
	//if (intersect(from, to)) return 1;
	
	for (int i = 0; i < v[from].size(); ++ i)
	{
		int w = v[from][i];
		//if (w == to) return 1;
		//if (insidetest(w,to)) return 1;
		if (Ldown[w]<Ldown[to] && Lup[w]>Lup[to] && flag[w]!= mark)
		{

			if (query(w,to)) return 1;
		}
	}
	return 0;
}
bool naiveQuery(int from, int to)
{
	flag[from] = mark;
	if (from == to) return 1;
	for (int i = 0; i < v[from].size(); ++ i)
	{
		int w = v[from][i];
		if (flag[w]!= mark)
		{
			if (naiveQuery(w,to)) return 1;
		}
		
	}
	return 0;
}
void query(string s)
{
	flag = new int[n];
	memset(flag,0,sizeof(int)*n);
	
	//read query
	vector<int> from;
	vector<int> to;
	fstream in;
	in.open(s.c_str(), ios::in);
	int t1, t2;
	while(in >> t1 >> t2)
	{
		from.push_back(t1);
		to.push_back(t2);
	}
	in.close();
	
	cout << "query number: " << from.size() << endl;
	
	timer.start();
	
	//begin query
	int queryNum = from.size();
	int reachNum = 0;
	for (int i = 0; i < queryNum; ++ i)
	{
		mark = i+1;
		bool arrive;
		if (from[i] == to[i]) arrive = 1;
		else if (Ldown[from[i]]>=Ldown[to[i]] || Lup[from[i]]<=Lup[to[i]]) arrive = 0;
		else if (toChain[from[i]] == toChain[to[i]] ) arrive = 1;
		else
		{
			mark = i+1;
			arrive = query(from[i],to[i]);
		}
		reachNum += arrive;
	}
	
	timer.stop();
	cout << "query time : " << timer.GetRuntime() << endl;
	cout << "reach number: " << reachNum<< endl;
	delete [] flag;
}
//----------------------query----------------------------


int main(int argc, char* argv[])
{
	string s;
	k = atoi(argv[1]);
	h = atoi(argv[2]);
	//s = "arxiv_scc.txt";
	s = argv[3];
	string s2;
	//s2 = "arxiv_query1000.txt";
	s2 = argv[4];
	readGraph(s);
	handle();
	query(s2);
	
	//cout << s << " " << s2 << endl;
}
